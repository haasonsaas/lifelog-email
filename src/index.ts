import { yesterday, fetchLifelogs, formatLifelogEntry, testDateRange } from './utils';
import { 
  ExtractorRegistry, 
  GptSummaryExtractor, 
  ActionItemsExtractor,
  DecisionsExtractor,
  ContactsExtractor,
  TopicsExtractor
} from './extractors/index';
import type { Env, Lifelog } from './types';
import type { ScheduledEvent, ExecutionContext } from "@cloudflare/workers-types";

// Global registry instance
const registry = new ExtractorRegistry({
  maxConcurrency: 3,
  extractorTimeout: 60000, // 60 seconds
  continueOnError: true
});

// Initialize extractors (done once when the worker starts)
let extractorsInitialized = false;

async function initializeExtractors(env: Env): Promise<void> {
  if (extractorsInitialized) return;
  
  // Helper function to check if an extractor is enabled via environment variables
  const isExtractorEnabled = (extractorName: string, defaultEnabled: boolean = true): boolean => {
    const envVar = `EXTRACTOR_${extractorName.toUpperCase()}_ENABLED`;
    const envValue = (env as any)[envVar];
    if (envValue === undefined) return defaultEnabled;
    return envValue.toLowerCase() === 'true';
  };
  
  // Register the GPT Summary extractor (always enabled as primary)
  const gptSummaryExtractor = new GptSummaryExtractor();
  await registry.register(gptSummaryExtractor, {
    enabled: isExtractorEnabled('gpt_summary', true),
    priority: 100
  });
  
  // Register the Action Items extractor
  const actionItemsExtractor = new ActionItemsExtractor();
  await registry.register(actionItemsExtractor, {
    enabled: isExtractorEnabled('action_items', true),
    priority: 90
  });
  
  // Register the Decisions extractor
  const decisionsExtractor = new DecisionsExtractor();
  await registry.register(decisionsExtractor, {
    enabled: isExtractorEnabled('decisions', true),
    priority: 80
  });
  
  // Register the Topics extractor
  const topicsExtractor = new TopicsExtractor();
  await registry.register(topicsExtractor, {
    enabled: isExtractorEnabled('topics', true),
    priority: 60
  });
  
  // Register the Contacts extractor (disabled by default for privacy)
  const contactsExtractor = new ContactsExtractor();
  await registry.register(contactsExtractor, {
    enabled: isExtractorEnabled('contacts', false),
    priority: 70
  });
  
  // Initialize all extractors
  await registry.initialize(env);
  extractorsInitialized = true;
  
  // Log enabled extractors
  const enabledExtractors = registry.getRegisteredExtractors()
    .filter(ext => ext.config.enabled)
    .map(ext => ext.name);
  console.log('Initialized extractors:', enabledExtractors.join(', '));
}

// Function to combine results from multiple extractors into a cohesive email
function combineExtractorResults(
  results: Array<{ extractorId: string; result: any }>, 
  env: Env
): { html: string; text: string } {
  // Get the timezone for date formatting
  const timezone = env.TIMEZONE || "America/Los_Angeles";
  const now = new Date(new Date().toLocaleString("en-US", { timeZone: timezone }));
  now.setDate(now.getDate() - 1);
  const dateStr = now.toLocaleDateString("en-US", { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric', 
    year: 'numeric' 
  });

  // Start with header
  let html = `<div style="font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto;">`;
  html += `<h1 style="color: #333; border-bottom: 2px solid #007cba; padding-bottom: 10px;">Daily Summary for ${dateStr}</h1>`;
  
  let text = `Daily Summary for ${dateStr}\n${'='.repeat(50)}\n\n`;

  // Order extractors by priority (highest first)
  const orderedResults = results.sort((a, b) => {
    const priorityA = getExtractorPriority(a.extractorId);
    const priorityB = getExtractorPriority(b.extractorId);
    return priorityB - priorityA;
  });

  // Combine results from each extractor
  orderedResults.forEach((resultItem, index) => {
    const { extractorId, result } = resultItem;
    
    // Add spacing between sections (except for the first one)
    if (index > 0) {
      html += `<div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e1e5e9;"></div>`;
      text += `\n${'-'.repeat(40)}\n\n`;
    }
    
    // Add the extractor result
    html += result.html;
    text += result.text;
    
    // Add section separator
    if (index < orderedResults.length - 1) {
      text += '\n\n';
    }
  });

  // Add footer
  html += `<div style="margin-top: 40px; padding-top: 20px; border-top: 2px solid #e1e5e9; font-size: 0.9em; color: #666;">`;
  html += `<p><em>Generated by lifelog-email system with ${results.length} extractor${results.length !== 1 ? 's' : ''}</em></p>`;
  html += `</div></div>`;
  
  text += `\n\n${'='.repeat(50)}\nGenerated by lifelog-email system with ${results.length} extractor${results.length !== 1 ? 's' : ''}`;

  return { html, text };
}

// Helper function to get extractor priority for ordering
function getExtractorPriority(extractorId: string): number {
  const priorities: Record<string, number> = {
    'gpt_summary': 100,
    'action_items': 90,
    'decisions': 80,
    'contacts': 70,
    'topics': 60
  };
  return priorities[extractorId] || 50;
}

async function runDigest(env: Env): Promise<void> {
  // Ensure extractors are initialized
  await initializeExtractors(env);
  
  const { start, end } = yesterday(env.TIMEZONE);
  const lifelogs = await fetchLifelogs(env.LIMITLESS_API_KEY, start, end);
  
  const logsWithMarkdown: Lifelog[] = lifelogs.map(log => ({
    ...log,
    contents: log.contents.map(content => ({
      ...content,
      type: content.type as "heading1" | "heading2" | "blockquote",
      speakerIdentifier: content.speakerIdentifier === "user" ? "user" : null
    })),
    markdown: formatLifelogEntry(log)
  }));

  // Execute all registered extractors
  const extractionResult = await registry.execute(logsWithMarkdown, env);
  
  // Handle extraction errors
  if (extractionResult.errors.length > 0) {
    console.error('Extractor errors:', extractionResult.errors);
    extractionResult.errors.forEach(error => {
      console.error(`  ${error.extractorId}: ${error.message}`);
    });
  }
  
  // Log execution summary
  console.log('Extraction summary:', extractionResult.summary);
  console.log(`Executed ${extractionResult.summary.successCount}/${extractionResult.summary.totalExtractors} extractors successfully`);
  
  if (extractionResult.results.length === 0) {
    throw new Error('No extractors produced results');
  }
  
  // Combine results from multiple extractors
  const combinedResult = combineExtractorResults(extractionResult.results, env);

  await fetch('https://api.resend.com/emails', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${env.RESEND_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      from: env.FROM_EMAIL,
      to: env.TO_EMAIL,
      subject: `Daily Summary for ${new Date().toLocaleDateString()}`,
      html: combinedResult.html,
      text: combinedResult.text,
    }),
  });
}

export default {
  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext): Promise<void> {
    await runDigest(env);
  },

  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const url = new URL(request.url);
    const path = url.pathname;

    if (path === "/preview") {
      // Ensure extractors are initialized
      await initializeExtractors(env);
      
      const { start, end } = testDateRange(env.TIMEZONE);
      console.log('Fetching lifelogs for date range:', { start, end });
      const lifelogs = await fetchLifelogs(env.LIMITLESS_API_KEY, start, end);
      console.log('Received lifelogs:', lifelogs.length);
      const logsWithMarkdown: Lifelog[] = lifelogs.map(log => ({
        ...log,
        contents: log.contents.map(content => ({
          ...content,
          type: content.type as "heading1" | "heading2" | "blockquote",
          speakerIdentifier: content.speakerIdentifier === "user" ? "user" : null
        })),
        markdown: formatLifelogEntry(log)
      }));
      console.log('Processed logs with markdown:', logsWithMarkdown.length);
      
      // Execute all extractors and combine results
      const extractionResult = await registry.execute(logsWithMarkdown, env);
      console.log('Extraction summary:', extractionResult.summary);
      
      if (extractionResult.results.length === 0) {
        return new Response('No extractors produced results', { 
          status: 500, 
          headers: { "Content-Type": "text/html" } 
        });
      }
      
      // Handle extraction errors in preview
      if (extractionResult.errors.length > 0) {
        console.error('Extractor errors in preview:', extractionResult.errors);
      }
      
      const combinedResult = combineExtractorResults(extractionResult.results, env);
      return new Response(combinedResult.html, { headers: { "Content-Type": "text/html" } });
    }

    if (path === "/test") {
      await runDigest(env);
      return new Response("Test email sent!");
    }

    return new Response("Not found", { status: 404 });
  },
};
